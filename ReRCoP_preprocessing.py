import re
import subprocess
import os


def readFasta(infile):
    '''
    This function reads in a fasta file and returns a dictionary with
    each key being the name of each sequence and the value being the
    sequence

    @param infile: input fasta file
    @return a dictionary
    '''
    output = {}
    trace = ""
    tmp = []
    inH = open(infile)
    for line in inH:
        line = line.strip('\n')
        if line.startswith(">"):
            if len(trace) > 0:
                output[trace] = "".join(tmp)
                tmp = []
            trace = line.split(' ')[0].lstrip('>')
        else:
            tmp.append(line)
    output[trace] = "".join(tmp)
    inH.close()
    return output


def fastaLen(infasta):
    '''
    This function reads in the first sequence in a fasta object and returns the
    sequence length.

    @param infasta: input fasta object
    @return: an int showing the sequence length
    '''
    key = infasta.keys()[0]
    return len(infasta[key])


def readGbk(infile):
    '''
    This function reads in a GenBank file and returns the locus tag, start position
    and end position of each gene binded together as a list of list

    @param infile: input genbank file
    @return: a list of list [[gene1.name, gene1.start, gene1.end], [gene2.name, 
    gene2.start, gene2.end], ...]
    '''
    output = []
    record = False
    pos = []
    inH = open(infile)
    for line in inH:
        line = line.strip()
        line = line.strip('\n')
        if line.startswith('CDS'):
            tmp = line.split()
            if len(tmp) > 1:
                pat = re.compile("(\d+)\.\.(\d+)")
                match = re.search(pat, tmp[1])
                pos = [match.group(1), match.group(2)]
                record = True
        elif record:
            pat = re.compile("=\"(.+)\"")
            name = re.search(pat, line).group(1)
            output.append([name,pos[0],pos[1]])
            record = False
    inH.close()
    return output


def filterCore(inDict, covCut):
    '''
    This function filters the genes involved in the concatenation based on
    the cutoffs provided.

    @param inDict: a dict with the gene sequences of a certain gene
    @param covCut: a cutoff that if at least this percent of the positions
    in a gene sequence should be covered to be called present
    @return a boolean value of whether include the gene or not
    '''
    passCov = 0
    for item in inDict:
        total = len(inDict[item])
        count = 0
        for c in inDict[item]:
            if c in ['A', 'T', 'C', 'G', 'a', 't', 'c', 'g']:
                count += 1
        if count >= float(covCut) * total:
            passCov += 1
    if passCov == len(inDict):
        return True
    return False


def slidingWindow(fullLen, fragSize, stepSize):
    '''
    This function generates sliding windows based on a fragment size and a step
    size as restricted by a full length. It returns a list of the count, the start 
    and end positions of each window.

    @param fullLen: the full length of the sequence to be splited 
    @param fragSize: the size of each fragment
    @param stepSize: the step size at which the fragments are creates. Set to the
    fragSize if the fragments are decided to be non-overlapping
    @return a list of the sart position and the end position of the fragments
    '''
    output = []
    current = 1
    count = 1
    for i in xrange(1,fullLen-fragSize+1,stepSize):
        output.append([count, current, current+fragSize-1])
        current += stepSize
        count += 1
    if current < fullLen:
        output.append([count, current, fullLen])
    return output


def parseGbk(gbk, fasta, covCut):
    '''
    This function takes in the fasta record and the genbank record, which would
    then extract the coding sequences from the fasta record, and returns a new
    fasta file which contains only the coding sequences and a concatenation record.

    @param gbk: the record generated by readGbk
    @param fasta: the record generated by readFasta
    @param covCut: the coverage cutoff for the function 'filterCore'
    @return [new_fasta, concatenation_log]
    '''
    log = []
    current = 1
    outFa = {}
    for seq in fasta:
        outFa[seq] = ""
    
    for i in xrange(len(gbk)):
        gbk[i][1] = int(gbk[i][1])
        gbk[i][2] = int(gbk[i][2])
        tmp = {}
        for seq in fasta:
            tmp[seq] = fasta[seq][gbk[i][1]-1:gbk[i][2]]
        if filterCore(tmp, covCut):
            for item in tmp:
                outFa[item] += tmp[item]
            log.append([gbk[i][0], current, gbk[i][2]-gbk[i][1]+current])
            current = gbk[i][2]-gbk[i][1]+current+1
    return[outFa, log]


def parseRaw(cds, seq, simCut, covCut, tmpFile1, tmpFile2, tmpFile3):
    '''
    This function extracts the core genome from the seququences based on the cds
    provided and returns the concatenated core genome file and the concatenation
    log.

    @param cds: a fasta object of the gene coding sequences for consideration
    @param seq: a fasta object of the genome sequences for to extract the core
    genome
    @param simCut: the similarity cutoff for defining the presence of a gene
    @param covCut: the coverage cutoff for the function 'filterCore'
    @param tmpFile1: a file that can write the tmp cds information into
    @param tmpFile2: a file that can write the tmp genome information into
    @param tmpFile3: a file that can write the tmp output information into
    @return [core_fasta, concatenation_log]
    '''

    storage = {}

    cdsH = open(tmpFile1, "w")
    for gene in cds:
        cdsH.write(">%s\n" % gene)
        cdsH.write("%s\n" % cds[gene])
        storage[gene] = {"ref":cds[gene]}
    cdsH.close()

    for genome in seq:
        tmpH = open(tmpFile2,'w')
        tmpH.write(">%s\n" % genome)
        tmpH.write("%s\n" % seq[genome])
        tmpH.close()

        subprocess.call(["makeblastdb", "-in", tmpFile2, "-out", tmpFile2, "-dbtype", "nucl"])
        subprocess.call(["blastn", "-query", tmpFile1, "-db", tmpFile2, "-task", "blastn", "-outfmt", "6 qseqid qlen sseqid qstart qend sstart send length pident qseq sseq", "-max_target_seqs", "1", "-out", tmpFile3])
        
        trace = ""
        inH = open(tmpFile3)
        for line in inH:
            line = line.strip('\n')
            tmp = line.split('\t')
            tmp[1] = int(tmp[1])
            tmp[3] = int(tmp[3])
            tmp[4] = int(tmp[4])
            tmp[7] = int(tmp[7])
            tmp[8] = float(tmp[8])
    
            if tmp[0] == trace or tmp[0] not in storage:
                continue
            trace = tmp[0]
            if (tmp[8] * tmp[7]) < (tmp[1] * simCut *covCut):
                del storage[trace]
                continue

            gap = [match.start() for match in re.finditer("-", tmp[9])]
            if len(gap) == 0:
                if tmp[1] == tmp[7]:
                    storage[trace][tmp[2]]=tmp[10]
                elif tmp[1] > tmp[7]:
                    tmpStr = ""
                    for i in range(1,tmp[3]):
                        tmpStr += '-'
                    tmpStr += tmp[10]
                    for i in range(tmp[4],tmp[1]):
                        tmpStr += '-'
                    storage[trace][tmp[2]] = tmpStr
            else:
                # Modify the reference sequence
                for key in storage[trace]:
                    for ind in gap:
                        storage[trace][key] = storage[trace][key][:ind] + 'N' + storage[trace][key][ind:]

                tmpStr = ""
                if tmp[3] != 1 or tmp[4] != tmp[2]:
                    for i in range(1,tmp[3]):
                        tmpStr += '-'
                    tmpStr += tmp[10]
                    for i in range(tmp[4],tmp[1]):
                        tmpStr += '-'
                else:
                    tmpStr = tmp[10]

                storage[trace][tmp[2]] = tmpStr

                # Build the reference again
                cdsH = open(tmpFile1, "w")
                for gene in storage:
                    cdsH.write(">%s\n" % gene)
                    cdsH.write("%s\n" % storage[gene]['ref'])
                cdsH.close()
        inH.close()

    output = {}
    log = []
    tmpPos = 1
    for gene in storage:
        log.append([gene, tmpPos, tmpPos+len(storage[gene]['ref'])-1])
        tmpPos += len(storage[gene]['ref'])

        for key in storage[gene]:
            if key != "ref":
                if key in output:
                    output[key] += storage[gene][key]
                else:
                    output[key] = storage[gene][key]

    os.remove(tmpFile1)
    os.remove(tmpFile2)
    os.remove(tmpFile3)
    os.remove(tmpFile2+".nsq")
    os.remove(tmpFile2+".nin")
    os.remove(tmpFile2+".nhr")

    return [output, log]


def consensus(inFasta):
    '''
    This function generates the consensus sequence from multiple fasta sequences
    alignments and returns as a fasta object.

    @param inFasta: a fasta object of multiple sequences alignments
    @return consensusSeq
    '''

    storage = []
    initialize = True
    consense = ""
    for key in inFasta:
        if initialize:
            for i in range(len(inFasta[key])):
                storage.append({inFasta[key][i]:1})
            initialize = False
        else:
            for i in range(len(inFasta[key])):
                if inFasta[key][i] in storage[i]:
                    storage[i][inFasta[key][i]] += 1
                else:
                    storage[i][inFasta[key][i]] = 1

    for i in range(len(storage)):
        key, _ = max(storage[i].iteritems(), key=lambda x:x[1])
        consense += key

    return consense
